---
slug: low-code-2-backend
title: 开源低代码平台开发实践二：从 0 构建一个基于ER图的低代码后端
author: 悠闲的水
author_title: 自由开发者
author_url: https://github.com/rxdrag
author_image_url: /img/avatar.jpg
tags: [低代码, 前端]
---

前后端分离了！

第一次知道这个事情的时候，内心是困惑的。

前端都出去搞 SPA，SEO 们同意吗？

后来，SSR 来了。

他说：“SEO 们同意了！”

任何人的反对，都没用了，时代变了。

各种各样的 SPA 们都来了，还有穿着跟 SPA 们一样衣服的各种小程序们。

为他们做点什么吧？于是 rxModels 诞生了，作为一个不希望被抛弃的后端，他希望能以更便捷的方式服务前端。

## rxModels 是什么？

一个款开源、通用、低代码后端。

使用 rxModels，只需要绘制 ER 图就可以定制一个开箱即用的后端。提供粒度精确到字段的权限管理功能，并对实例级别的权限管理提供表达式支持。

主要模块有：图形化的实体、关系管理界面( rx-models Client)，通用JSON格式的数据操作接口服务( rx-models )，前端调用辅助 Hooks 库( rxmodels-swr )等。

rxModels 基于 TypeScript，NestJS，TypeORM 和 Antv x6 实现。

TypeScript 的强类型支持，可以把一些错误在编译时就解决掉了，IDE有了强类型的支持，可以自动引入依赖，提高了开发效率，节省了时间。

TypeScript 编译以后的目标执行码时JS，一种运行时解释语言，这个特性赋予了 rxModels 动态发布实体和热加载 `指令` 的能力。用户可以使用 `指令` 实现业务逻辑，扩展通用 JSON 数据接口。给 rxModels 增加了更多使用场景。

NestJS 有助于代码的组织，使其拥有一个良好的架构。

TypeORM 是一款轻量级 ORM 库，可以把对象模型映射到关系数据库。它能够 “分离实体定义”，传入 JSON 描述就可以构建数据库，并对数据库提供面向对象的查询支持。得益于这个特性，图形化的业务模型转换成数据库数据库模型，rxModels 仅需要少量代码就可以完成。

AntV X6 功能相对已经比较全面了，它支持在节点(node)里面嵌入 React组件，利用这个个性，使用它来绘制 ER 图，效果非常不错。如果后面有时间，可以再写一篇文章，介绍如何使用 AntV x6绘制 ER 图。

要想跟着本文，把这个项目一步步做出来，最好能够提前学习一下本节提到的技术栈。

## rxModels 目标定位

主要为中小项目服务。

为什么不敢服务大项目？

真不敢，作者是业余程序员，没有大项目相关的任何经验。

## 开撸第一步：梳理数据及数据映射

先看一下演示，从直观上知道项目的样子：[rxModels演示](https://rxmodels-client.rxdrag.com/) 。

![界面](/img/blog/blog2-rxmodels-client.jpg)

### 元数据定义

元数据(Meta)，用于描述业务实体模型的数据。一部分元数据转化成 TypeORM 实体定义，随之生成数据库；另一部分元数据业务模型在图形界面的信息，比如实体的大小跟位置，关系的位置跟形状等。

需要转化成 TypeORM 实体定义的元数据有：

```typescript title="实体元数据"
import { ColumnMeta } from "./column-meta";

/**
* 实体类型枚举，目前仅支持普通实体跟枚举实体，
* 枚举实体类似语法糖，不映射数据库，
* 枚举类型的字段映射到数据库是sttring类型
*/
export enum EntityType{
  NORMAL = "Normal",
  ENUM = "Enum",
}

/**
* 实体元数据
*/
export interface EntityMeta{
  /** 唯一标识 */
  uuid: string;

  /** 实体名称 */
  name: string;

  /** 表名，如果tableName没有被设置，会把实体名转化成蛇形命名法当作表名 */
  tableName?: string;

  /** 实体类型 */
  entityType?: EntityType|"";

  /** 字段有元数据列表 */
  columns: ColumnMeta[];

  /** 枚举值JSON，枚举类型实体使用，不参与数据库映射 */
  enumValues?: any;
}
```
```typescript title="字段元数据"

/**
* 字段类型，枚举，目前版本仅支持这些类型，后续可以扩展
*/
export enum ColumnType{

  /** 数字类型 */
  Number = 'Number',

  /** 枚举类型 */
  Boolean = 'Boolean',

  /** 字符串类型 */  
  String = 'String',

  /** 日期类型 */  
  Date = 'Date',

  /** JSON类型 */
  SimpleJson = 'simple-json',

  /** 数组类型 */
  SimpleArray = 'simple-array',

  /** 枚举类型 */
  Enum = 'Enum'
}

/**
* 字段元数据，基本跟 TypeORM Column 对应
*/
export interface ColumnMeta{

  /** 唯一标识 */
  uuid: string;

  /** 字段名 */
  name: string;

  /** 字段类型 */
  type: ColumnType;

  /** 是否主键 */
  primary?: boolean;

  /** 是否自动生成 */
  generated?: boolean;

  /** 是否可空 */
  nullable?: boolean;

  /** 字段默认值 */
  default?: any;

  /** 是否唯一 */
  unique?: boolean;

  /** 是否是创建日期 */
  createDate?: boolean;

  /** 是否是更新日期 */
  updateDate?: boolean;

  /** 是否是删除日期，软删除功能使用 */
  deleteDate?: boolean;

  /**
   * 是否可以在查询时被选择，如果这是为false，则查询时隐藏。
   * 密码字段会使用它
   */
  select?: boolean;

  /** 长度 */
  length?: string | number;

  /** 当实体是枚举类型时使用 */
  enumEnityUuid?:string;

  /**
   * ============以下属性跟TypeORM对应，但是尚未启用
   */
  width?: number;
  version?: boolean;
  readonly?: boolean;  
  comment?: string;
  precision?: number;
  scale?: number;
}
```

```typescript title="关系元数据"
/**
 * 关系类型
 */
export enum RelationType {
  ONE_TO_ONE = 'one-to-one',
  ONE_TO_MANY = 'one-to-many',
  MANY_TO_ONE = 'many-to-one',
  MANY_TO_MANY = 'many-to-many',
}

/**
 * 关系元数据
 */
export interface RelationMeta {
  /** 唯一标识 */
  uuid: string;

  /** 关系类型 */  
  relationType: RelationType;

  /** 关系的源实体标识 */  
  sourceId: string;

  /** 关系目标源实体标识 */  
  targetId: string;

  /** 源实体上的关系属性 */  
  roleOnSource: string;

  /** 目标实体上的关系属性  */    
  roleOnTarget: string;

  /** 拥有关系的实体ID，对应TypeORM的JoinTable或JoinColumn */
  ownerId?: string;
}
```

不需要转化成 TypeORM 实体定义的元数据有：

```typescript title="包元数据"
/**
 * 包的元数据
 */
export interface PackageMeta{
  /** ID，主键  */
  id?: number;

  /** 唯一标识 */
  uuid: string;

  /** 报名 */
  name: string;

  /**实体列表 */
  entities?: EntityMeta[];

  /**ER图列表 */
  diagrams?: DiagramMeta[];

  /**关系列表 */
  relations?: RelationMeta[];
}
```

```typescript title="ER图元数据"
import { X6EdgeMeta } from "./x6-edge-meta";
import { X6NodeMeta } from "./x6-node-meta";

/**
 * ER图元数据
 */
export interface DiagramMeta {
  /** 唯一标识 */
  uuid: string;

  /** ER图名称 */
  name: string;

  /** 节点 */
  nodes: X6NodeMeta[];

  /** 关系的连线 */
  edges: X6EdgeMeta[];
}

```
```typescript title="ER图节点元数据"
export interface X6NodeMeta{
  /** 对应实体标识uuid */
  id: string;
  /** 节点x坐标 */
  x?: number;
  /** 节点y坐标  */
  y?: number;
  /** 节点宽度 */
  width?: number;
  /** 节点高度 */
  height?: number;
}
```

```typescript title="关系线条元数据"
import { Point } from "@antv/x6";

export type RolePosition = {
  distance: number,
  offset: number,
  angle: number,
}
export interface X6EdgeMeta{
  /** 对应关系 uuid */
  id: string;

  /** 折点数据 */
  vertices?: Point.PointLike[];

  /** 源关系属性位置标签 */
  roleOnSourcePosition?: RolePosition;

  /** 目标关系属性位置标签 */
  roleOnTargetPosition?: RolePosition;
}
```
rxModels有一个后端服务，基于这些数据构建数据库。rxModels有一个前端管理界面，管理并生产这些数据。

## 服务端 rx-models

整个项目的核心，基于NestJS构建。需要安装TypeORM，只安装普通TYPEORM核心项目，不需要安装NestJS的封装模块。

``` console
nest new rx-models

cd rx-models

npm install npm install typeorm
```
这只是关键安装，其他的库，不一一列举了。

具体项目已经完成了，代码地址：[https://github.com/rxdrag/rx-models](https://github.com/rxdrag/rx-models)。

第一个版本承担技术探索的任务，仅支持MySQL足够了。

### 通用接口设计

### 登录接口

### 客户端元数据存储

### 安装接口

### 为什么没用GraphQL？

## 客户端 rx-models-client
需要一个客户端，管理生产并管理元数据，测试通用数据查询接口，设置实体权限，安装等。创建一个普通的 React，项目支持 TypeScript。

```console
npx create-react-app rx-models-client--template typescript
```
这个项目已经完成了，在GitHub上，代码地址：[https://github.com/rxdrag/rx-models-client](https://github.com/rxdrag/rx-models-client)。

代码量有点多，全部在这里展开解释，有点放不下。只能挑关键点说一下，有问题需要交流的话，请跟作者联系。

### ER图 - 图形化的业务模型

### 接口测试

### 权限管理

### 安装、登录

## 服务端 rx-models

## 与前端的第一次接触

rxModels来了，热情的走向前端们。

前端们皱起了眉头，说：“离远点儿，你不是我们理想中的样子。”

rxModels 说：“我还会改变，还会成长，未来的某一天，我们一定是最好的搭档。”




数据的流转：

1. 制作业务实体模型 -> 实体模型以 JSON 格式保存在数据库 

2. 发布业务实体模型 -> 被发布的实体模型以 JSON文件格式保存在后端目录

3. 服务端启动 -> 从发布目录读取实体模型 -> 转化成 TypeORM能识别的格式 -> TypeORM同步数据库

核心的数据结构有两个：

1. 绘图界面使用的数据，用于保存包、实体、关系、ER 图。这个数据可以被客户端制作并保存，也可以根据这些数据重新把ER图什么的再渲染出来。

2. TypeORM能够接受的实体定义数据

第二部分我们不需要定义，请参考 TypeORM 文档。第一部分是我们关注的重点，这部分数据到底该如何组织？

ER图就是实体关系图，它的核心元素只有两个：实体、关系。

实体包含字段字段，字段有具体类型。关系有三种：1对1，1对多，多对多。

实体、字段、关系，这三方面的信息需要完全映射到数据库，不能多也不能少。这些信息要在后端传递给TypeORM。

还有一些信息，是为了用户便于管理、便于理解的，不影响数据库结构，比如实体在哪个包里，实体在ER图中的位置以及大小，关系在ER图中的位置及形状。